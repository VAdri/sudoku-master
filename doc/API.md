<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

-   [Input/Output (IO)][1]
    -   [parseGrid][2]
        -   [Parameters][3]
        -   [Examples][4]
    -   [serializeGrid][5]
        -   [Parameters][6]
        -   [Examples][7]
    -   [solvingDescription][8]
        -   [Parameters][9]
        -   [Examples][10]
    -   [eliminationDescription][11]
        -   [Parameters][12]
        -   [Examples][13]
    -   [cellIdentifier][14]
        -   [Parameters][15]
        -   [Examples][16]
    -   [cellsIdentifiers][17]
        -   [Parameters][18]
        -   [Examples][19]
    -   [houseIdentifier][20]
        -   [Parameters][21]
-   [Solver (brute-force)][22]
    -   [solveWithBacktracking][23]
        -   [Parameters][24]
        -   [Examples][25]
-   [Solver (logical)][26]
    -   [solveFullHouse][27]
        -   [Parameters][28]
    -   [solveHiddenSingle][29]
        -   [Parameters][30]
    -   [solveLastDigit][31]
        -   [Parameters][32]
    -   [solveNakedSingle][33]
        -   [Parameters][34]
    -   [eliminateLockedCandidates][35]
        -   [Parameters][36]
        -   [Examples][37]
    -   [eliminateNakedSubset][38]
        -   [Parameters][39]
        -   [Examples][40]

## Input/Output (IO)

Send and receive data with the program.


### parseGrid

-   **See: [http://sudopedia.enjoysudoku.com/Diagrams_and_Notations.html][41]
    **
-   **See: [http://www.sadmansoftware.com/sudoku/faq22.php][42]
    **

Converts a string into a sudoku grid.

The string can contain only big numbers (digits), in which case the empty
cells must be marked with one of these symbols: ".", "-", "\*", "0"; or it
can also contain the little numbers (or candidates), in which case they
need to be grouped (using brackets around them or putting spaces between
them for instance) in order to be able to differentiate each cell.

The grid can be organized in a single line, in multiple lines or as a grid
(with symbols representing the grid lines). The regular expressions used to
validate these formats are exported in constants prefixed with "PATTERN\_".

#### Parameters

-   `stringGrid` **[string][43]** The string representing a sudoku grid.
-   `addCandidates` **[boolean][44]** Indicates that the parser can find the candidates if they are not provided by
    the given string. (optional, default `false`)
-   `onlyCleanString` **[boolean][44]** The string must match one of the clean patterns. (optional, default `false`)

#### Examples

```javascript
const grid = parseGrid(`
  +---+---+---+
  |*23|4**|8**|
  |6**|**7|***|
  |***|53*|62*|
  +---+---+---+
  |**5|***|***|
  |84*|***|*36|
  |***|***|1**|
  +---+---+---+
  |*52|*96|***|
  |***|1**|**7|
  |**8|**5|21*|
  +---+---+---+
`);
```

Returns **(SudokuGrid | null)** The `SudokuGrid` that was parsed, or `null` if the given string was not in a valid
format.

**Meta**

-   **since**: 0.0.1

### serializeGrid

Converts a Sudoku grid into a string that can be read by humans or converted back into a Sudoku program.

#### Parameters

-   `grid` **SudokuGrid** The grid to serialize.
-   `options` **SerializerOptions?** Options to apply on the serialized output.
    -   `options.style` **(`"singleLine"` \| `"multiLines"` \| `"grid"` \| `"sudopedia"`)** Describes the formatting style of the
        output. (optional, default `"singleLine"`)
    -   `options.pencilmarks` **[boolean][44]** Indicates whether to show the candidates on the output.
    -   `options.brackets` **(`"{}"` \| `"()"` \| `"[]"`)** The brackets to use arround the cells (only for singleLine and
        multiLines styles). (optional, default `undefined`)
    -   `options.emptyCellSymbol` **(`"."` \| `"*"` \| `"-"` \| `"0"`)** The symbol to use to indicate an empty cell. (optional, default `"."`)

#### Examples

```javascript
const grid = parseGrid(".234..8..6....7......53.62...5......84.....36......1...52.96......1....7..8..521.");
const options = {
   style: "singleLine",
   pencilmarks: true,
   brackets: "{}",
 };
serializeGrid(grid, options);
// => {1579}{2}{3}{4}{16}{19}{8}{579}{159}{6}{189}{149}{289}{128}{7}{3459}{459}{13459}{1479}{1789}{1479}{5}{3}{189}{6}{2}{149}{12379}{13679}{5}{236789}{124678}{123489}{479}{4789}{2489}{8}{4}{179}{279}{1257}{129}{579}{3}{6}{2379}{3679}{679}{236789}{245678}{23489}{1}{45789}{24589}{1347}{5}{2}{378}{9}{6}{34}{48}{348}{349}{369}{469}{1}{248}{2348}{3459}{45689}{7}{3479}{3679}{8}{37}{47}{5}{2}{1}{349}
```

Returns **[string][43]** The grid converted into a string.

**Meta**

-   **since**: 0.0.1

### solvingDescription

Give a description of a solving (e.g. "Full House: r5c8=3" means that the digit 3 can be placed in the cell on row 5
and column 8 according to the Full House technique).

#### Parameters

-   `solvingResult`  The solving to describe.

#### Examples

```javascript
solvingDescription({ technique: "Full House", coord: [4, 7], digit: 3 });
// => "Full House: r5c8=3"
```

Returns **[string][43]** A description of the solving.

### eliminationDescription

Give a description of an elimination (e.g. "Locked Candidates Type 1 (Pointing): 5 in b1 => r3c7&lt;>5" means that the
candiadte 5 can be eliminated in the cell on row 3 and column 7 according to the Locked Candidates Type 1 technique
beacaus the digit 5 is in box 1).

#### Parameters

-   `eliminationResult`  The elimination to describe.

#### Examples

```javascript
const grid = parseGrid(
  ":0101:7:+31+8..+54.+6...6.3+8+1...6.8.+5.38+6+495+21+3+7+12+34+7+6+958795+3+1+8+2+6+4.+3.5..7+8......7+3.+5....3+9641::732:",
);
const result = eliminateLockedCandidates({ digits: grid.digits, candidates: getCandidates(grid.digits) });
eliminationDescription(result[0]);
// => "Locked Candidates Type 2 (Claiming): 7 in r2 => r3c2<>7"
```

Returns **[string][43]** A description of the elimination.

**Meta**

-   **since**: 0.0.3

### cellIdentifier

-   **See: [http://sudopedia.enjoysudoku.com/Diagrams_and_Notations.html#Cell_Reference][45]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Rncn.html][46]
    **
-   **See: [http://sudopedia.enjoysudoku.com/K9.html][47]
    **

Identify the given cell using the [rncn][46] or
[k9][47] notation.

#### Parameters

-   `cell` **(CellCoord | GridIndex | CellHouse)** The cell to identify.
-   `mode` **CellNotationMode** The type of notation. (optional, default `"rncn"`)

#### Examples

```javascript
cellIdentifier([4, 1]);
// => "r5c2"
cellIdentifier([4, 1], "k9");
// => "e2"
```

Returns **[string][43]** The identifier for the given cells.

**Meta**

-   **since**: 0.0.2

### cellsIdentifiers

-   **See: [http://sudopedia.enjoysudoku.com/Diagrams_and_Notations.html#Cell_Reference][45]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Rncn.html][46]
    **
-   **See: [http://sudopedia.enjoysudoku.com/K9.html][47]
    **

Identify the given cell or group of cells using the [rncn][46] or
[k9][47] notation.

**Note:** The "rncn" mode (by default) can group multiple cells in a single one if they share the same rows and
columns.

#### Parameters

-   `cells` **ReadonlyArray&lt;(CellCoord | GridIndex | CellHouse)>** The cells to identify.
-   `mode` **CellNotationMode** The type of notation. (optional, default `"rncn"`)

#### Examples

```javascript
cellsIdentifiers([[4, 1]]);
// => ["r5c2"]
cellsIdentifiers([[4, 1]], "k9");
// => ["e2"]
cellsIdentifiers([[0, 5], [0, 7]], "rncn");
// => ["r1c68"]
cellsIdentifiers([
  { houseType: "box", houseIndex: 0, cellIndex: 0 },
  { houseType: "row", houseIndex: 0, cellIndex: 5 },
  { houseType: "col", houseIndex: 7, cellIndex: 0 },
  { houseType: "box", houseIndex: 3, cellIndex: 0 },
  { houseType: "row", houseIndex: 3, cellIndex: 5 },
  { houseType: "col", houseIndex: 7, cellIndex: 3 },
]);
// => ["r14c168"]
cellsIdentifiers([0, 5, 7, 27, 32, 34, 37, 38, 46, 47, 63]);
// => ["r14c168", "r56c23", "r8c1"]
```

**Meta**

-   **since**: 0.0.2

### houseIdentifier

Get the identifier of a house (e.g. "b5" means box 5).

#### Parameters

-   `house`  The house to identify.

Returns **any** The identifier of the house.

**Meta**

-   **since**: 0.0.3

## Solver (brute-force)

Computer-oriented algorithms used to solve a Sudoku.


### solveWithBacktracking

-   **See: [http://sudopedia.enjoysudoku.com/Backtracking_Algorithms.html][48]
    **
-   **See: [https://en.wikipedia.org/wiki/Backtracking][49]
    **
-   **See: [https://en.wikipedia.org/wiki/Sudoku_solving_algorithms][50]
    **

Solves a grid using a backtracking algorithm.

The program will place a digit into a cell (following the constraints of the game), and continue until it finds the
solution or hits a dead end. If the algorithm cannot place any new digit according to the constraints of the game,
meaning it has reached a dead end, it removes the one or several placed digits and tries a new alternative. This
process continue until either all alternatives have been tried or the grid has been solved.

**Note:** This process can be slow. Some grids are also designed to resist this kind of algorithm for a longer time.

#### Parameters

-   `grid` **SudokuGrid** The grid to solve.
-   `mode` **BruteForceMode** The type of algorithm to use to solve the puzzle. (optional, default `BruteForceMode.DepthFirstSearch`)

#### Examples

```javascript
const grid = parseGrid(`
  +---+---+---+
  |-7-|2-3|-8-|
  |345|798|126|
  |2-8|-4-|---|
  +---+---+---+
  |4--|5-9|8-2|
  |-5-|8-4|-9-|
  |8--|---|--1|
  +---+---+---+
  |---|---|--8|
  |-8-|---|-7-|
  |62-|-87|-15|
  +---+---+---+`);
const solution = solveWithBacktracking(grid);
serializeGrid({ digits: solution, candidates: new Map() });
// => "971263584345798126268145937437519862156824793892376451713952648584631279629487315"
```

Returns **(ReadonlyMap&lt;GridIndex, Digit> | [undefined][51])** The solution of the grid if it has been found; otherwise,
`undefined`.

**Meta**

-   **since**: 0.0.1

## Solver (logical)

Find patterns used to solve a Sudoku with human logic.


### solveFullHouse

-   **See: [http://sudopedia.enjoysudoku.com/Full_House.html][52]
    **

Finds a house with a single unsolved cell.

#### Parameters

-   `grid` **SudokuGrid** The grid to solve.
-   `skip` **[number][53]** Indicates to skip some of the solving results. (optional, default `0`)
-   `count` **[number][53]** Indicates the maximum amount of results to return. (optional, default `1`)

**Meta**

-   **since**: 0.0.2

### solveHiddenSingle

-   **See: [http://sudopedia.enjoysudoku.com/Hidden_Single.html][54]
    **

Find a house containing a single candidate remaining for a specific digit.

#### Parameters

-   `grid` **SudokuGrid** The grid to solve.
-   `skip` **[number][53]** Indicates to skip some of the solving results. (optional, default `0`)
-   `count` **[number][53]** Indicates the maximum amount of results to return. (optional, default `1`)

**Meta**

-   **since**: 0.0.2

### solveLastDigit

-   **See: [http://sudopedia.enjoysudoku.com/Last_Digit.html][55]
    **

Finds a digit with a single unsolved cell.

#### Parameters

-   `grid` **SudokuGrid** The grid to solve.
-   `skip` **[number][53]** Indicates to skip some of the solving results. (optional, default `0`)
-   `count` **[number][53]** Indicates the maximum amount of results to return. (optional, default `1`)

**Meta**

-   **since**: 0.0.2

### solveNakedSingle

-   **See: [http://sudopedia.enjoysudoku.com/Naked_Single.html][56]
    **

Finds a cell containing only one candidate.

#### Parameters

-   `grid` **SudokuGrid** The grid to solve.
-   `skip` **[number][53]** Indicates to skip some of the solving results. (optional, default `0`)
-   `count` **[number][53]** Indicates the maximum amount of results to return. (optional, default `1`)

**Meta**

-   **since**: 0.0.2

### eliminateLockedCandidates

-   **See: [http://sudopedia.enjoysudoku.com/Locked_Candidates.html][57]
    **

When all candidates for a digit in a house are located inside the intersection with another house, we can eliminate
the remaining candidates from the second house outside the intersection.

#### Parameters

-   `grid`  The grid to solve.

#### Examples

```javascript
const grid = parseGrid("2.....1..14..2..83..3.1.5.............67...5.8.92.13.......32....18.2.3....16..94", true);
const results = eliminateLockedCandidates(grid);
eliminationDescription(results[0]);
// => "Locked Candidates Type 1 (Pointing): 4 in b3 => r46c8<>4"
```

Returns **any** A list of objects describing where a candidate can be eliminated.

**Meta**

-   **since**: 0.0.3

### eliminateNakedSubset

-   **See: [http://sudopedia.enjoysudoku.com/Naked_Subset.html][58]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Naked_Pair.html][59]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Naked_Triple.html][60]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Naked_Quad.html][61]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Locked_Pair.html][62]
    **
-   **See: [http://sudopedia.enjoysudoku.com/Locked_Triple.html][63]
    **

A Naked Subset is formed by N cells in a house with candidates for exactly N digits. It cause the elimination of the
digits that are on the same house but not in the cells of the subet.

**Note:** When all cells are located in an intersection, spotting the subset is much easier. Because there are only
three cells in an intersection, it is not possible to find Naked Quadruples in an intersection. The subset can cause
eliminations in both intersecting houses.

#### Parameters

-   `grid`  The grid to solve.
-   `level`  The level of the subset to find.

#### Examples

```javascript
const grid = parseGrid(
  ":0201:6:...+2+94+3+8....17+86+4.48.3561....4+8+375.+1...+41+57..5..+62+9+83495+3+7+8+2+4+1612+6+5+4+3+9+78.+4.+9+6+1+2+5+3::612: ",
  true,
);
const results = eliminateNakedSubset(grid, SubsetLevel.Triple);
eliminationDescription(results[0]);
// => "Naked Triple: 3,6,9 in r245c2 => r1c2<>6"
```

Returns **any** A list of objects describing where a candidate can be eliminated.

[1]: #inputoutput-io

[2]: #parsegrid

[3]: #parameters

[4]: #examples

[5]: #serializegrid

[6]: #parameters-1

[7]: #examples-1

[8]: #solvingdescription

[9]: #parameters-2

[10]: #examples-2

[11]: #eliminationdescription

[12]: #parameters-3

[13]: #examples-3

[14]: #cellidentifier

[15]: #parameters-4

[16]: #examples-4

[17]: #cellsidentifiers

[18]: #parameters-5

[19]: #examples-5

[20]: #houseidentifier

[21]: #parameters-6

[22]: #solver-brute-force

[23]: #solvewithbacktracking

[24]: #parameters-7

[25]: #examples-6

[26]: #solver-logical

[27]: #solvefullhouse

[28]: #parameters-8

[29]: #solvehiddensingle

[30]: #parameters-9

[31]: #solvelastdigit

[32]: #parameters-10

[33]: #solvenakedsingle

[34]: #parameters-11

[35]: #eliminatelockedcandidates

[36]: #parameters-12

[37]: #examples-7

[38]: #eliminatenakedsubset

[39]: #parameters-13

[40]: #examples-8

[41]: http://sudopedia.enjoysudoku.com/Diagrams_and_Notations.html

[42]: http://www.sadmansoftware.com/sudoku/faq22.php

[43]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String

[44]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean

[45]: http://sudopedia.enjoysudoku.com/Diagrams_and_Notations.html#Cell_Reference

[46]: http://sudopedia.enjoysudoku.com/Rncn.html

[47]: http://sudopedia.enjoysudoku.com/K9.html

[48]: http://sudopedia.enjoysudoku.com/Backtracking_Algorithms.html

[49]: https://en.wikipedia.org/wiki/Backtracking

[50]: https://en.wikipedia.org/wiki/Sudoku_solving_algorithms

[51]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined

[52]: http://sudopedia.enjoysudoku.com/Full_House.html

[53]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number

[54]: http://sudopedia.enjoysudoku.com/Hidden_Single.html

[55]: http://sudopedia.enjoysudoku.com/Last_Digit.html

[56]: http://sudopedia.enjoysudoku.com/Naked_Single.html

[57]: http://sudopedia.enjoysudoku.com/Locked_Candidates.html

[58]: http://sudopedia.enjoysudoku.com/Naked_Subset.html

[59]: http://sudopedia.enjoysudoku.com/Naked_Pair.html

[60]: http://sudopedia.enjoysudoku.com/Naked_Triple.html

[61]: http://sudopedia.enjoysudoku.com/Naked_Quad.html

[62]: http://sudopedia.enjoysudoku.com/Locked_Pair.html

[63]: http://sudopedia.enjoysudoku.com/Locked_Triple.html
